#include "Prerequisites.cuh"

#define TpB 1024

namespace gtom
{
	template<uint nrefs, bool doprecalcshifts, bool dofirstitercc> __global__ void SquaredDifferencesKernel(const tcomplex* __restrict__ d_particleft, const tfloat* __restrict__ d_minvsigma2, const tfloat* __restrict__ d_ctf, uint elements, const tcomplex* __restrict__ d_precalcshifts, const tcomplex* __restrict__ d_refft, tfloat* d_diff2, bool* d_doproceed);

	void d_rlnSquaredDifferences(tcomplex* d_particleft, tfloat* d_minvsigma2, tfloat* d_ctf, int3 dimsparticle, uint nparticles, tcomplex* d_precalcshifts, uint nshifts, tcomplex* d_refft, uint nrefs, uint nrefbatches, tfloat* d_diff2, bool* d_doproceed, bool doprecalcshifts, bool dofirstitercc)
	{
		uint elements = ElementsFFT(dimsparticle);
		dim3 grid = dim3(nshifts, nparticles, nrefbatches);
		if (nrefs == 1)
			if (doprecalcshifts)
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<1, true, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<1, true, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
			else
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<1, false, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<1, false, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
		else if (nrefs <= 2)
			if (doprecalcshifts)
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<2, true, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<2, true, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
			else
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<2, false, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<2, false, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
		else if (nrefs <= 4)
			if (doprecalcshifts)
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<4, true, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<4, true, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
			else
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<4, false, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<4, false, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
		else if (nrefs <= 8)
			if (doprecalcshifts)
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<8, true, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<8, true, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
			else
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<8, false, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<8, false, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
		else if (nrefs <= 16)
			if (doprecalcshifts)
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<16, true, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<16, true, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
			else
			{
				if (dofirstitercc)
					SquaredDifferencesKernel<16, false, true> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
				else
					SquaredDifferencesKernel<16, false, false> << <grid, TpB >> >(d_particleft, d_minvsigma2, d_ctf, elements, d_precalcshifts, d_refft, d_diff2, d_doproceed);
			}
		else
			throw;
	}

	template<uint nrefs, bool doprecalcshifts, bool dofirstitercc> __global__ void __launch_bounds__(TpB) SquaredDifferencesKernel(const tcomplex* __restrict__ d_particleft, const tfloat* __restrict__ d_minvsigma2, const tfloat* __restrict__ d_ctf, uint elements, const tcomplex* __restrict__ d_precalcshifts, const tcomplex* __restrict__ d_refft, tfloat* d_diff2, bool* d_doproceed)
	{
		__shared__ bool doproceed;
		if (threadIdx.x == 0)
			doproceed = d_doproceed[(blockIdx.z * gridDim.y + blockIdx.y) * gridDim.x + blockIdx.x];
		__syncthreads();
		if (!doproceed)
			return;

		__shared__ tfloat s_diff2[(TpB / 32) * nrefs];
		__shared__ tfloat s_suma2[dofirstitercc ? (TpB / 32) * nrefs : 1];

		for (uint i = threadIdx.x; i < TpB / 32 * nrefs; i += TpB)
		{
			s_diff2[i] = 0;
			if (dofirstitercc)
				s_suma2[i] = 0;
		}

		if (doprecalcshifts)
		{
			d_particleft += elements * blockIdx.y;
			d_precalcshifts += elements * blockIdx.x;
		}
		else
		{
			d_particleft += (blockIdx.y * gridDim.x + blockIdx.x) * elements;
		}

		// Offset to current refbatch
		d_refft += elements * nrefs * blockIdx.z;
		d_diff2 += (nrefs * blockIdx.z * gridDim.y + blockIdx.y) * gridDim.x + blockIdx.x;

		d_minvsigma2 += elements * blockIdx.y;
		d_ctf += elements * blockIdx.y;

		tfloat diff2, suma2;
		bool thread0 = threadIdx.x % 32 == 0;
		uint warpid = threadIdx.x / 32;

		for (uint id = threadIdx.x; id < elements; id += TpB)
		{
			tcomplex particleshifted = doprecalcshifts ? cmul(d_particleft[id], d_precalcshifts[id]) : d_particleft[id];
			tfloat minvsigma2 = dofirstitercc ? 0 : d_minvsigma2[id];
			tfloat ctf = d_ctf[id];

			size_t offset = id;

			for (uchar n = 0; n < nrefs; n++)
			{
				if (dofirstitercc)
				{
					tcomplex ref = d_refft[offset] * ctf;
					diff2 = particleshifted.x * ref.x + particleshifted.y * ref.y;
					suma2 = dotp2(ref, ref);
				}
				else
				{
					tcomplex diff = make_cuComplex(d_refft[offset].x * ctf - particleshifted.x, d_refft[offset].y * ctf - particleshifted.y);
					diff2 = dotp2(diff, diff) * minvsigma2;
				}
				offset += elements;

				for (int w = 16; w > 0; w /= 2)
				{
					diff2 += __shfl_down(diff2, w);
					if (dofirstitercc)
						suma2 += __shfl_down(suma2, w);
				}

				if (thread0)
				{
					s_diff2[(TpB / 32) * n + warpid] += diff2;
					if (dofirstitercc)
						s_suma2[(TpB / 32) * n + warpid] += suma2;
				}
			}
		}

		__syncthreads();
		
		if (threadIdx.x < TpB / 64)
			for (uchar n = 0; n < nrefs; n++)
			{
				diff2 = s_diff2[(TpB / 32) * n + threadIdx.x] + s_diff2[(TpB / 32) * n + threadIdx.x + (TpB / 64)];

				if (dofirstitercc)
					suma2 = s_suma2[(TpB / 32) * n + threadIdx.x] + s_suma2[(TpB / 32) * n + threadIdx.x + (TpB / 64)];
			
				for (int w = TpB / 128; w > 0; w /= 2)
				{
					diff2 += __shfl_down(diff2, w);

					if (dofirstitercc)
						suma2 += __shfl_down(suma2, w);
				}

				if (threadIdx.x == 0)
				{
					if (dofirstitercc)
						diff2 *= rsqrt(suma2);
					else
						diff2 *= 0.5f;

					d_diff2[n * gridDim.y * gridDim.x] = diff2;
				}
			}
	}
}
